package main

import (
	"fmt"
	"path/filepath"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage   = protogen.GoImportPath("context")
	grpcPackage      = protogen.GoImportPath("google.golang.org/grpc")
	embedPackage     = protogen.GoImportPath("embed")
	runtimePackage   = protogen.GoImportPath("github.com/grpc-ecosystem/grpc-gateway/v2/runtime")
	goGRPCMiddleware = protogen.GoImportPath("github.com/grpc-ecosystem/go-grpc-middleware")
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if file.Generate {
				generateFile(plugin, file)
			}
		}

		return nil
	})
}

// generateFile generates a .pb.burito.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".pb.burito.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-burito. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the gRPC service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	name := serviceName(service)

	// Swagger docs
	g.Import(embedPackage)
	g.P()
	g.P("//go:embed ", filepath.Base(file.GeneratedFilenamePrefix), ".swagger.json")
	g.P("var Swagger []byte")
	g.P()

	// Wrapper struct
	g.P("type ", name, " struct {")
	g.P(service.GoName, "Server")
	g.P("interceptor ", g.QualifiedGoIdent(grpcPackage.Ident("UnaryServerInterceptor")))
	g.P("}")
	g.P()

	// NewWrapper factory
	g.P("func New", name, "(")
	g.P("srv ", service.GoName, "Server,")
	g.P("mws ...", g.QualifiedGoIdent(grpcPackage.Ident("UnaryServerInterceptor")), ",")
	g.P(") ", "*", name, " {")
	g.P("return &", name, "{")
	g.P(service.GoName, "Server: srv,")
	g.P("interceptor:", g.QualifiedGoIdent(goGRPCMiddleware.Ident("ChainUnaryServer")), "(mws...),")
	g.P("}")
	g.P("}")
	g.P()

	// Name
	g.P("func(w *", name, ") Name() string {")
	g.P("return \"", filepath.Base(file.GeneratedFilenamePrefix), "\"")
	g.P("}")
	g.P()

	// Swagger docs.
	g.P("func(w *", name, ") Swagger() []byte {")
	g.P("return Swagger")
	g.P("}")
	g.P()

	// Server registration.
	g.P("func(w *", name, ") RegisterGRPC(s *", g.QualifiedGoIdent(grpcPackage.Ident("Server")), ") {")
	g.P("Register", service.GoName, "Server(s, w)")
	g.P("}")
	g.P()

	g.P("func(w *", name, ") RegisterGateway(")
	g.P("ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",")
	g.P("mux *", g.QualifiedGoIdent(runtimePackage.Ident("ServeMux")), ",")
	g.P(") error {")
	g.P("return Register", service.GoName, "HandlerServer(ctx, mux, w)")
	g.P("}")
	g.P()

	g.P("// middleware wrapper")
	g.P()
	// Wrapper method implementations.
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			genServerMethod(gen, file, g, method)
		}
	}
}

func genServerMethod(
	gen *protogen.Plugin,
	file *protogen.File,
	g *protogen.GeneratedFile,
	method *protogen.Method,
) {
	service := method.Parent
	name := serviceName(service)
	serverName := service.GoName + "Server"

	g.P("func (w *", name, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", in *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	g.P("if w.interceptor == nil { return w.", serverName, ".", method.GoName, "(ctx, in) }")
	g.P("info := &", grpcPackage.Ident("UnaryServerInfo"), "{")
	g.P("Server: w,")
	g.P("FullMethod: ", strconv.Quote(fmt.Sprintf("/%s/%s", service.Desc.FullName(), method.Desc.Name())), ",")
	g.P("}")
	g.P("handler := func(ctx ", contextPackage.Ident("Context"), ", req interface{}) (interface{}, error) {")
	g.P("return w.", serverName, ".", method.GoName, "(ctx, req.(*", method.Input.GoIdent, "))")
	g.P("}")
	g.P("resp, err := w.interceptor(ctx, in, info, handler)")
	g.P("if err != nil || resp == nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("return resp.(*", method.Output.GoIdent, "), err")
	g.P("}")
	g.P()
}

func serviceName(service *protogen.Service) string {
	return service.GoName + "Wrapper"
}
